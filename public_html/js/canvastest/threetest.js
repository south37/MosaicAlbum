// Generated by CoffeeScript 1.6.3
$(function() {
  return window.addEventListener("DOMContentLoaded", function() {
    return $.getJSON("/common/mosaic_viewer/ajax_list", function(data) {
      var anim, aspect, camera, cnt, col, controlMode, directioalLight, farClip, fov, geometry, height, materialNumbers, materials, nearClip, path, pathList, pclientX, pclientY, piece, piecedata, pieces, pieces_tween, position, projector, renderer, rendering, row, scene, sizeX, sizeY, target, tex, texlist, trackball, trans, width, _i, _len, _ref;
      console.log(data);
      width = window.innerWidth;
      height = window.innerHeight;
      renderer = new THREE.WebGLRenderer();
      renderer.setSize(width, height);
      $("#container").before(renderer.domElement);
      renderer.setClearColor(0x000000, 1);
      scene = new THREE.Scene();
      fov = 80;
      aspect = width / height;
      nearClip = 1;
      farClip = 10000;
      camera = new THREE.PerspectiveCamera(fov, aspect, nearClip, farClip);
      target = new THREE.Vector3(0, 0, 0);
      camera.position.set(0, 0, 1000);
      scene.add(camera);
      camera.lookAt(target);
      trackball = new THREE.TrackballControls(camera, renderer.domElement);
      directioalLight = new THREE.DirectionalLight(0xffffff, 3);
      directioalLight.position.z = 300;
      scene.add(directioalLight);
      pathList = ["resize_0.png", "resize_1.png", "resize_2.png", "resize_3.png", "resize_4.png", "resize_5.png", "resize_6.png", "resize_7.png", "resize_8.png", "resize_9.jpg"];
      texlist = (function() {
        var _i, _len, _results;
        _results = [];
        for (_i = 0, _len = pathList.length; _i < _len; _i++) {
          path = pathList[_i];
          _results.push(new THREE.ImageUtils.loadTexture('/img/resize_img/' + path));
        }
        return _results;
      })();
      materials = (function() {
        var _i, _len, _results;
        _results = [];
        for (_i = 0, _len = texlist.length; _i < _len; _i++) {
          tex = texlist[_i];
          _results.push(new THREE.MeshBasicMaterial({
            map: tex
          }));
        }
        return _results;
      })();
      materialNumbers = {
        "img/resize_img/1/1.png": 0,
        "img/resize_img/1/2.png": 1,
        "img/resize_img/1/3.png": 2,
        "img/resize_img/1/4.png": 3,
        "img/resize_img/1/5.png": 4,
        "img/resize_img/1/6.png": 5,
        "img/resize_img/1/7.png": 6,
        "img/resize_img/1/8.png": 7,
        "img/resize_img/1/9.png": 8
      };
      row = 80;
      col = 60;
      sizeX = 1000 / col;
      sizeY = 1000 / row;
      sizeX = 10;
      sizeY = 10;
      geometry = new THREE.PlaneGeometry(sizeX, sizeY, 1, 1);
      pieces = [];
      pieces_tween = [];
      /*
      for i in [0..col]
        tmppieces = []
        for j in [0..row]
          piece = new THREE.Mesh(geometry,materials[(i+j)%10])
          piece.position.set sizeX*i - 500, -600, 0
          scene.add(piece)
          tmppieces.push piece
        pieces.push tmppieces
      */

      cnt = 0;
      _ref = data.mosaicPieces;
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        piecedata = _ref[_i];
        piece = new THREE.Mesh(geometry, materials[materialNumbers[piecedata.resize_image_path]]);
        position = new THREE.Vector3(cnt - 1000, -500, 0);
        piece.position.copy(position);
        scene.add(piece);
        /*
        target = new THREE.Vector3(piecedata.x * sizeX - 500, 500 - piecedata.y * sizeY, 0)
        movetime = 500
        delaytime = 500 + 100 * cnt
        twn = new TWEEN.Tween(piece.position)
          .to(target , movetime)
          .delay(delaytime)
        pieces_tween.push twn
        */

        cnt += 1;
      }
      projector = new THREE.Projector();
      $(renderer.domElement).bind('mousedown', function(e) {
        var mouseX, mouseY, obj, ray, vec;
        console.log("rendererclicked");
        mouseX = ((e.pageX - e.target.offsetParent.offsetLeft) / renderer.domElement.width) * 2 - 1;
        mouseY = ((e.pageY - e.target.offsetParent.offsetTop) / renderer.domElement.height) * 2 - 1;
        vec = new THREE.Vector3(mouseX, mouseY, 0);
        projector.unprojectVector(vec, camera);
        ray = new THREE.Raycaster(camera.position, vec.sub(camera.position).normalize());
        obj = ray.intersectObjects(scene.children, true);
        if (obj.length > 0) {
          return console.log("object clicked", obj[0].object.id);
        } else {
          return console.log("no clicked object");
        }
      });
      controlMode = "none";
      pclientX = 0;
      pclientY = 0;
      $('canvas').mousedown(function(e) {
        return controlMode = "move";
      });
      $('canvas').mouseup(function() {
        var twn, _j, _len1, _results;
        controlMode = "none";
        /*
        for i in [0..col]
          for j in [0..row]
            movetime = 200 * Math.floor( Math.random() * (row+col))
            trans(pieces[i][j],new THREE.Vector3(sizeX*i-500,sizeY*j-500,0),100,500 + movetime)
        */

        _results = [];
        for (_j = 0, _len1 = pieces_tween.length; _j < _len1; _j++) {
          twn = pieces_tween[_j];
          _results.push(twn.start());
        }
        return _results;
      });
      $('canvas').mousemove(function(e) {
        var diff;
        switch (controlMode) {
          case "move":
            diff = new THREE.Vector3(-e.clientX + pclientX, e.clientY - pclientY, 0);
            camera.position.add(diff);
            break;
          case "zoom":
            diff = new THREE.Vector3(0, 0, e.clientY - pclientY);
            camera.position.add(diff);
            break;
          case "target":
            diff = new THREE.Vector3(-e.clientX + pclientX, e.clientY - pclientY, 0);
            target.add(diff);
            camera.lookAt(target);
            break;
          case "reset":
            camera.position.set(0, 0, 500);
            target.set(0, 0, 0);
            camera.lookAt(target);
            controlMode = "none";
            break;
          case "none":
            console.log("none");
        }
        pclientX = e.clientX;
        return pclientY = e.clientY;
      });
      $(this).keypress(function(e) {
        console.log(e.which);
        switch (e.which) {
          case 113:
            return controlMode = controlMode === "move" ? "none" : "move";
          case 119:
            return controlMode = controlMode === "zoom" ? "none" : "zoom";
          case 101:
            return controlMode = controlMode === "target" ? "none" : "target";
          case 97:
            return controlMode = "reset";
          default:
            return controlMode = "none";
        }
      });
      rendering = function() {
        return renderer.render(scene, camera);
      };
      trans = function(object, target, duration, delay) {
        return new TWEEN.Tween(object.position).to(target, duration).delay(delay).easing(TWEEN.Easing.Linear.None).start();
      };
      anim = function() {
        requestAnimationFrame(anim);
        trackball.update();
        TWEEN.update();
        return renderer.render(scene, camera);
      };
      renderer.render(scene, camera);
      return anim();
    });
  });
});

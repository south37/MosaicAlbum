// Generated by CoffeeScript 1.6.3
$(function() {
  console.log("load threetest.coffee");
  return window.addEventListener("DOMContentLoaded", function() {
    var anim, aspect, camera, col, controlMode, directioalLight, far, fov, geometry, height, i, j, materials, near, path, pathList, pclientX, pclientY, piece, pieces, render, rendering, row, scene, sizeX, sizeY, target, tex, texlist, tmppieces, trans, width, _i, _j;
    width = window.innerWidth;
    height = window.innerHeight;
    render = new THREE.WebGLRenderer();
    render.setSize(width, height);
    $("#container").before(render.domElement);
    render.setClearColor(0x000000, 1);
    scene = new THREE.Scene();
    fov = 80;
    aspect = width / height;
    near = 1;
    far = 10000;
    camera = new THREE.PerspectiveCamera(fov, aspect, near, far);
    target = new THREE.Vector3(0, 0, 0);
    camera.position.set(0, 0, 1000);
    scene.add(camera);
    camera.lookAt(target);
    directioalLight = new THREE.DirectionalLight(0xffffff, 3);
    directioalLight.position.z = 300;
    scene.add(directioalLight);
    pathList = ["resize_0.png", "resize_1.png", "resize_2.png", "resize_3.png", "resize_4.png", "resize_5.png", "resize_6.png", "resize_7.png", "resize_8.png", "resize_9.jpg"];
    texlist = (function() {
      var _i, _len, _results;
      _results = [];
      for (_i = 0, _len = pathList.length; _i < _len; _i++) {
        path = pathList[_i];
        _results.push(new THREE.ImageUtils.loadTexture('/img/resize_img/' + path));
      }
      return _results;
    })();
    materials = (function() {
      var _i, _len, _results;
      _results = [];
      for (_i = 0, _len = texlist.length; _i < _len; _i++) {
        tex = texlist[_i];
        _results.push(new THREE.MeshBasicMaterial({
          map: tex
        }));
      }
      return _results;
    })();
    row = 80;
    col = 60;
    sizeX = 1000 / col;
    sizeY = 1000 / row;
    geometry = new THREE.PlaneGeometry(sizeX, sizeY, 1, 1);
    pieces = [];
    for (i = _i = 0; 0 <= col ? _i <= col : _i >= col; i = 0 <= col ? ++_i : --_i) {
      tmppieces = [];
      for (j = _j = 0; 0 <= row ? _j <= row : _j >= row; j = 0 <= row ? ++_j : --_j) {
        piece = new THREE.Mesh(geometry, materials[(i + j) % 10]);
        piece.position.set(sizeX * i - 500, -600, -10);
        scene.add(piece);
        tmppieces.push(piece);
      }
      pieces.push(tmppieces);
    }
    controlMode = "none";
    pclientX = 0;
    pclientY = 0;
    $('canvas').mousedown(function(e) {
      console.log("mousedown:", e);
      return controlMode = "move";
    });
    $('canvas').mouseup(function() {
      var _k, _results;
      console.log("mouseup");
      controlMode = "none";
      _results = [];
      for (i = _k = 0; 0 <= col ? _k <= col : _k >= col; i = 0 <= col ? ++_k : --_k) {
        _results.push((function() {
          var _l, _results1;
          _results1 = [];
          for (j = _l = 0; 0 <= row ? _l <= row : _l >= row; j = 0 <= row ? ++_l : --_l) {
            trans(pieces[i][j], new THREE.Vector3(sizeX * i - 500, sizeY * j - 500, 0), 100, 500 + 100 * (Math.floor(Math.random() * (row + col))));
            _results1.push(console.log(i, ":", j));
          }
          return _results1;
        })());
      }
      return _results;
    });
    $('canvas').mousemove(function(e) {
      var diff;
      switch (controlMode) {
        case "move":
          diff = new THREE.Vector3(-e.clientX + pclientX, e.clientY - pclientY, 0);
          camera.position.add(diff);
          break;
        case "zoom":
          diff = new THREE.Vector3(0, 0, e.clientY - pclientY);
          camera.position.add(diff);
          break;
        case "target":
          diff = new THREE.Vector3(-e.clientX + pclientX, e.clientY - pclientY, 0);
          target.add(diff);
          camera.lookAt(target);
          break;
        case "reset":
          camera.position.set(0, 0, 500);
          target.set(0, 0, 0);
          camera.lookAt(target);
          controlMode = "none";
          break;
        case "none":
          console.log("none");
      }
      pclientX = e.clientX;
      return pclientY = e.clientY;
    });
    $(this).keypress(function(e) {
      console.log(e.which);
      switch (e.which) {
        case 113:
          return controlMode = controlMode === "move" ? "none" : "move";
        case 119:
          return controlMode = controlMode === "zoom" ? "none" : "zoom";
        case 101:
          return controlMode = controlMode === "target" ? "none" : "target";
        case 97:
          return controlMode = "reset";
        default:
          return controlMode = "none";
      }
    });
    rendering = function() {
      return render.render(scene, camera);
    };
    trans = function(object, target, duration, delay) {
      return new TWEEN.Tween(object.position).to(target, duration).delay(delay).easing(TWEEN.Easing.Linear.None).start();
    };
    anim = function() {
      requestAnimationFrame(anim);
      TWEEN.update();
      return render.render(scene, camera);
    };
    render.render(scene, camera);
    return anim();
  });
});
